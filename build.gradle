import com.bmuschko.gradle.docker.tasks.container.DockerCopyFileFromContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerWaitContainer
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import groovyx.net.http.RESTClient
import org.apache.http.client.methods.HttpPut
import org.apache.http.entity.FileEntity
import org.apache.http.impl.client.DefaultHttpClient

buildscript {
    ext {
        grailsVersion = project.grailsVersion
    }
    repositories {
        mavenLocal()
        if (System.getenv('MAVEN_REPO')) {
          maven { url { System.getenv('MAVEN_REPO') } }
        }
        maven { url "https://repo.grails.org/grails/core" }
    }
    dependencies {
        classpath "org.grails:grails-gradle-plugin:$grailsVersion"
        classpath "com.bertramlabs.plugins:asset-pipeline-gradle:2.14.3"
        classpath "org.grails.plugins:hibernate5:${gormVersion-".RELEASE"}"
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.2'
        classpath 'com.bmuschko:gradle-docker-plugin:2.6.7'
        classpath 'com.netflix.nebula:gradle-lint-plugin:7.9.2'
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.15.0'
    }
}

plugins {
    id 'com.gradle.build-scan' version '1.8'
    id 'com.craigburke.client-dependencies' version '1.4.0'
}

apply plugin:"eclipse"
apply plugin:"idea"
apply plugin:"war"
apply plugin:"org.grails.grails-web"
apply plugin:"org.grails.grails-gsp"
apply plugin:"asset-pipeline"
apply plugin: "com.bmuschko.docker-remote-api"
apply plugin: 'nebula.lint'

allprojects {
    apply plugin: 'com.github.ben-manes.versions'
}

version "0.1"
group "pet.store"

buildScan {
    licenseAgreementUrl = 'https://gradle.com/terms-of-service'
    licenseAgree = 'yes'
}

ext {
    grailsVersion = project.grailsVersion
    gradleWrapperVersion = project.gradleWrapperVersion
    cacheDir = gradle.getGradleUserHomeDir() as String ?: "${System.getProperty("user.home")}/.cache/gradle"
    new File(cacheDir).mkdirs()

    commit = System.getenv("COMMIT_HASH") ?: "git rev-parse HEAD".execute().text.trim()
}

bootRun {
    jvmArgs('-Dspring.output.ansi.enabled=always')
    addResources = true
}

assets {
    minifyJs = true
    minifyCss = true
}

/** Use the typical docker-machine environment variables to configure docker. */
ext {
    dockerHost = null
}
docker {
    if (System.getenv('DOCKER_TLS_VERIFY') == '1' && System.getenv('DOCKER_CERT_PATH')) {
        url = System.getenv('DOCKER_HOST')?.replaceAll('tcp://', 'https://')
        certPath = new File(System.getenv('DOCKER_CERT_PATH'))
        project.dockerHost = new URL(url).host
    } else if (System.getenv('DOCKER_HOST')) {
        url = System.getenv('DOCKER_HOST')?.replaceAll('tcp://', 'http://')
        project.dockerHost = new URL(url).host
    }
}

repositories {
    mavenLocal()
    if (System.getenv('MAVEN_REPO')) {
      maven { url { System.getenv('MAVEN_REPO') } }
    }
    maven { url "https://repo.grails.org/grails/core" }
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.4.10'
    compile 'org.grails:grails-plugin-rest:3.2.10'
    compile 'org.springframework:spring-tx:4.3.7.RELEASE'
    compile 'io.projectreactor:reactor-core:2.0.8.RELEASE'
    compile 'org.apache.tomcat.embed:tomcat-embed-core:8.5.13'
    compile 'org.grails:grails-web-sitemesh:3.2.10'
    compile 'org.grails:grails-bootstrap:3.2.10'
    compile 'org.springframework:spring-beans:4.3.7.RELEASE'
    compile 'org.springframework.boot:spring-boot:1.4.6.RELEASE'
    compile 'org.springframework:spring-context:4.3.7.RELEASE'
    compile 'org.grails:grails-web-url-mappings:3.2.10'
    compile 'org.grails:grails-plugin-mimetypes:3.2.10'
    compile 'org.springframework:spring-webmvc:4.3.7.RELEASE'
    compile 'org.grails:grails-web-databinding:3.2.10'
    compile 'org.grails:grails-databinding:3.2.10'
    compile 'org.grails:grails-datastore-core:6.0.10.RELEASE'
    compile 'org.grails:grails-web-common:3.2.10'
    compile 'org.grails:grails-plugin-async:3.2.10'
    compile 'org.grails:grails-web-taglib:3.2.10'
    compile 'org.grails:grails-datastore-gorm:6.0.10.RELEASE'
    compile 'org.grails:grails-taglib:3.2.10'
    compile 'io.projectreactor:reactor-bus:2.0.8.RELEASE'
    compile 'org.codehaus.groovy:groovy:2.4.10'
    compile 'org.grails:grails-plugin-events:3.2.10'
    compile 'org.grails:grails-web-mvc:3.2.10'
    compile 'org.slf4j:slf4j-api:1.7.25'
    compile 'org.grails:grails-plugin-converters:3.2.10'
    compile 'org.grails:grails-plugin-controllers:3.2.10'
    compile 'org.springframework:spring-web:4.3.7.RELEASE'
    compile 'org.grails:grails-plugin-domain-class:3.2.10'
    testCompile 'org.grails:grails-datastore-simple:6.0.10.RELEASE'
    testCompile 'org.springframework:spring-test:4.3.7.RELEASE'
    testCompile 'junit:junit:4.12'
    testCompile 'org.grails:grails-test:3.2.10'
    compile "org.springframework.boot:spring-boot-autoconfigure"
    compile "org.grails:grails-core"
    compile "org.grails:grails-dependencies"
    compile "org.grails:grails-web-boot"
    runtime 'org.hibernate:hibernate-ehcache:5.1.3.Final'
    console "org.grails:grails-console"
    profile "org.grails.profiles:web"
    runtime "com.bertramlabs.plugins:asset-pipeline-grails:2.14.3"
    runtime "org.grails.plugins:scaffolding"
    runtime "org.grails.plugins:cache"
    runtime "com.h2database:h2"
    testCompile "org.grails:grails-plugin-testing"

    // Note: It is recommended to update to a more robust driver (Chrome, Firefox etc.)
    testRuntime "org.seleniumhq.selenium:selenium-htmlunit-driver:2.52.0"
    testRuntime "net.sourceforge.htmlunit:htmlunit:2.27"

    console "org.grails:grails-console"
}

clientDependencies {
    yarn {
        'jquery'('~2.1.0')
        "angular"("~1.3.15")
        "angular-route"("~1.3.15")
        "angular-loader"("~1.3.15")
        "angular-animate"("~1.3.15")
        "angular-cookies"("~1.3.15")
        "angular-resource"("~1.3.15")
        "angular-sanitize"("~1.3.15")
        "angular-touch"("~1.3.15")
        "angular-mocks"("~1.3.15")
        "animate.css"("3.x")
    }
}

allprojects {
    dependencyUpdates.resolutionStrategy = {
        componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                if (['.M', '.RC', 'beta', 'alpha', '-rc'].find {
                    selection.candidate.version.toLowerCase().contains(it.toLowerCase())
                }) {
                    selection.reject('unreleased')
                }
            }
        }
    }

    gradleLint.rules = ['all-dependency','depenency-parenthesis','depenency-tuple']
    autoLintGradle.onlyIf { false }
}

task wrapper(type: Wrapper) {
    gradleVersion = gradleWrapperVersion
}

/**
 * Uploading a source tarball with the compiled jar and an empty maven build to make the Java buildpack happy
 */
task emptyPom {
    outputs.file('build/pom.xml')
    doLast {
        new File('build/pom.xml').text = """
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>pet.store</groupId>
  <artifactId>placeholder</artifactId>
  <packaging>jar</packaging>
  <version>1.0</version>
  <name>Pet Store</name>
  <build>
    <finalName>placeholder</finalName>
  </build>
</project>
"""
    }
}

task herokuSources(type: Tar, dependsOn: [emptyPom, bootRepackage]) {
    description = "Package binary application into Heroku sources for faster deployment"
    group = "distribution"
    appendix = "heroku"
    compression = Compression.GZIP
    from 'Procfile'
    from 'system.properties'
    from 'build/pom.xml'
    into('src/main/dist') {
       from war.archivePath
    }
}

// Documentation at https://devcenter.heroku.com/articles/build-and-release-using-the-api
task deployToHeroku(dependsOn: herokuSources) {
    description = 'Deploy the application to Heroku via the Platform API REST services'
    group = "distribution"
    doLast {
        RESTClient heroku = new RESTClient("https://api.heroku.com/apps/${System.getenv("HEROKU_APP_NAME")}/")
        heroku.headers['Authorization'] = "Bearer ${System.getenv('HEROKU_AUTH_TOKEN')}"
        heroku.headers['Accept'] = 'application/vnd.heroku+json; version=3'

        // upload sources
        def sources = heroku.post(path: 'sources')
        def put_url = sources.data.source_blob.put_url
        def get_url = sources.data.source_blob.get_url

        // upload sources, Heroku/AWS is very picky about the headers sent, so we need to use this way. For example, Content-Type must not be present
        logger.info("Uploading ${herokuSources.archivePath} to ${put_url}")
        def res = new DefaultHttpClient().execute(new HttpPut(URI: new URI(put_url), entity: new FileEntity(herokuSources.archivePath)))
        if (res.statusLine.statusCode > 399) {
            throw new IOException(res.statusLine.reasonPhrase)
        }

        // start the build
        logger.info("Building ${get_url}")
        heroku.post(path: 'builds', requestContentType: 'application/json',
            body: ['source_blob': ['url':get_url, 'version': "git rev-parse HEAD".execute().text.trim() ]]
        )
    }
    onlyIf { System.getenv('HEROKU_AUTH_TOKEN') && System.getenv('HEROKU_APP_NAME') }
}

processResources.dependsOn clientInstall
assetCompile.dependsOn clientInstall

build.dependsOn ':staticsite:generate'

/**
 * Container based tasks follow. These tasks allow all build operations to be done in containers,
 * thus reducing the dependencies required on the build host to be Java and Docker.
 */

/** Download all dependencies, this will be run in a container to cache the dependencies. */
task primeCache {
    doLast {
        project.rootProject.allprojects.each { subProject ->
            subProject.buildscript.configurations.each { configuration ->
                configuration.resolve()
            }
            subProject.configurations.each { configuration ->
                configuration.resolve()
            }
        }
    }
}

/** The `dockerOutput` directory holds all build outputs from the containers. */
ext {
  dockerOutput = "${project.buildDir}/docker/output"
  hostMap = [:]
}

/** We want to maintain any proxy configurations and there might be hosts in /etc/hosts, so let's resolve those */
new File("/etc/hosts").eachLine { String line ->
    def split = line.split('\\s+')
    def ip = split[0]
    if ([~/#.*/, ~/127\..*/, ~/::.*/, ~/255\..*/].find { ip ==~ it } == null) {
        split.drop(1).each { host ->
            hostMap[host] = ip
        }
    }
}
String hostResolve(String str) {
    hostMap.each { host, ip ->
        str = str.replaceAll("//${host}([:/])", "//${ip}\$1")
    }
    str
}

/** Construct the context for a base image which is the source code without build artifacts. */
task dockerBaseContext(type: Sync) {
  group = "staging"
  into "${project.buildDir}/docker/base"
  from project.projectDir

  def initGradle = new File("${cacheDir}/init.gradle")
  if (initGradle.exists() && initGradle.file) {
      from(initGradle) {
          filter { hostResolve(it) }
      }
  }

  def npmrc = new File("${System.getProperty("user.home")}/.npmrc")
  if (npmrc.exists() && npmrc.file) {
      from(npmrc) {
          filter { (it ==~ /\s*registry\s*=.*/ || it ==~ /\s*phantomjs.*=.*/) ? hostResolve(it) : null }
      }
  }

  exclude '.git'
  // Re-use the information in .gitignore to exclude non-source artifacts (build, IDE, etc.)
  if (file('.gitignore').exists()) {
    file('.gitignore').eachLine { exclude it.replaceFirst("^/", "") }
  }

  doLast {
      if (hostMap['nexus']) {
          def wrapperProps = file("${project.buildDir}/docker/base/gradle/wrapper/gradle-wrapper.properties")
          if (wrapperProps.file) {
              def text = wrapperProps.text
              text = text.replaceAll(
                      ~/https\\:\\/\\/services.gradle.org\\/distributions\\/gradle-([0-9.]+)-([A-Za-z]+).zip/,
                      "http\\\\://${hostMap['nexus']}:9081/content/groups/public/org/gradle/wrapper/\$1/gradle-\$1-\$2.zip")
              wrapperProps.text = text
          }
      }
  }
}

/** 
 * Dockerfile for a base image that contains Gradle, Node and other dependencies stored in the cache.  This
 * image will be re-built occasionally to reflect new dependencies. There is a bit of complexity here with using
 * a user account named 'r'. Bower refuses to run as root, so we need to do this.
 */
task dockerBaseDockerfile(type: Dockerfile) {
  dependsOn dockerBaseContext
  destFile = file("${project.buildDir}/docker/base/Dockerfile")
  from 'java:8'
  maintainer 'Patrick Double "pat@patdouble.com"' 
  environmentVariable 'TERM', 'dumb'
  environmentVariable 'GRADLE_USER_HOME', '/cache'
  runCommand "adduser --disabled-password --gecos '' r  && adduser r sudo && echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers"
  runCommand "mkdir /cache && chown r /cache && mkdir /app && chown r /app && mkdir /prime && chown r /prime"
  runCommand 'echo org.gradle.daemon=true >> /cache/gradle.properties'
  workingDir '/prime'

  copyFile 'gradle', '/prime/gradle/'
  copyFile 'gradlew', '/prime/'
  user 'r'
  runCommand './gradlew --version' // cache gradle distro before dependencies

  user 'root'
  copyFile '.', '/prime/'
  runCommand 'chown -R r /prime'
  user 'r'
  if (new File(destFile.parentFile, "init.gradle").file) {
      copyFile 'init.gradle', '/cache/'
  }
  if (new File(destFile.parentFile, ".npmrc").file) {
      copyFile '.npmrc', '${HOME}/'
  }
  runCommand './gradlew -is clientInstall'
  runCommand './gradlew -is primeCache'
  runCommand 'mv /prime/node_modules /cache'
  runCommand 'mv /prime/bower_components /cache'
  user 'root'
  runCommand 'rm -rf /prime'
  user 'r'
  workingDir '/app'
  //'/cache (GRADLE_USER_HOME) is populated with dependencies'
  //'Issue the following commands before running the container:'
  //'  COPY . /app'
  //'  RUN chown -R r /app'
  //'  USER r'
}

/**
 * Build a base image that can be built upon with the source code. The tag should always be
 * 'latest' since we'll use this for multiple versions of the app code. It's not terribly important to
 * keep this synced up with the current code base, new or changed dependencies will be downloaded.
 * A periodic rebuild of the base image is recommended with possibly a manual build when things change
 * dramatically.
 */
task dockerBaseImage(type: DockerBuildImage) {
  group = 'staging'
  dependsOn dockerBaseDockerfile
  inputDir = dockerBaseDockerfile.destFile.parentFile
  tag = "double16/pet-store_base"
}

/**
 * Dockerfile for an app container with the current source code, ready to be built. The entry point will
 * be Gradle so only the tasks need to be sent.
 */
task dockerAppDockerfile(type: Dockerfile) {
  group = 'staging'
  dependsOn dockerBaseContext
  destFile = file("${project.buildDir}/docker/base/Dockerfile.app")
  from dockerBaseImage.tag
  maintainer 'Patrick Double "pat@patdouble.com"'
  environmentVariable 'COMMIT_HASH', commit
  user 'root'
  workingDir '/app'
  copyFile '.', '/app/'
  runCommand 'chown -R r /app'
  user 'r'
  entryPoint './gradlew','--info','--stacktrace'
  defaultCommand 'check'
}

/**
 * Build the app container and tag with the git short commit hash.
 */
task dockerAppImage(type: DockerBuildImage) {
  group = 'staging'
  dependsOn dockerAppDockerfile
  dockerFile = dockerAppDockerfile.destFile
  inputDir = dockerAppDockerfile.destFile.parentFile
  tag = "double16/pet-store_app:${'git rev-parse HEAD'.execute().text.trim().take(12) ?: 'latest'}"
}

/**
 * The following set of tasks create a container that executes the `check` task and extracts
 * the test artifacts into the host filesystem.
 */
task dockerCreateCheck(type: DockerCreateContainer) {
  dependsOn dockerAppImage
  targetImageId { dockerAppImage.getImageId() }
  cmd = ['check']
  attachStdout = true
  attachStderr = true
}
task dockerStartCheck(type: DockerStartContainer) {
  dependsOn dockerCreateCheck
  targetContainerId { dockerCreateCheck.getContainerId() }
}
/**
 * We need to wait for the `check` task to complete, docker is running this in the background.
 */
task dockerWaitCheck(type: DockerWaitContainer) {
  dependsOn dockerCreateCheck
  targetContainerId { dockerCreateCheck.getContainerId() }
}
task dockerCheckResults(type: DockerCopyFileFromContainer) {
  dependsOn dockerWaitCheck
  targetContainerId { dockerCreateCheck.getContainerId() }
  remotePath '/app/build/test-results'
  hostPath "${dockerOutput}/test-results"
  doFirst {
    file(dockerOutput).mkdirs()
    file(hostPath).deleteDir()
  }
  outputs.dir file("${dockerOutput}/test-results")
}
task dockerCheckReports(type: DockerCopyFileFromContainer) {
  dependsOn dockerWaitCheck
  targetContainerId { dockerCreateCheck.getContainerId() }
  remotePath '/app/build/reports'
  hostPath "${dockerOutput}/reports"
  doFirst {
    file(dockerOutput).mkdirs()
    file(hostPath).deleteDir()
  }
  outputs.dir file("${dockerOutput}/reports")
}
/**
 * NOTE: this is the task to run
 */
task dockerCheck {
  dependsOn dockerStartCheck
  finalizedBy dockerCheckResults, dockerCheckReports
}
/**
 * End of 'check' container tasks.
 */

task dockerClean(type: Exec) {
    group = "staging"
    description = "Stop and remove all docker containers"
    commandLine '/bin/sh','-c','docker ps -qa | xargs docker rm -f; docker volume ls -q | xargs docker volume rm; docker images | grep \'<none>\' | tr -s [:space:] | cut -d " " -f 3 | xargs docker rmi'
}

/**
 * Static site container.
 */
task dockerStaticSiteContext(type: Sync) {
  group = "staging"
  dependsOn ':staticsite:generate'
  into "${project.buildDir}/docker/staticsite/content"
  from project(':staticsite').file('target')
}

task dockerStaticSiteDockerfile(type: Dockerfile) {
  group = 'staging'
  dependsOn dockerStaticSiteContext
  destFile = file("${project.buildDir}/docker/staticsite/Dockerfile")
  from 'sebp/lighttpd:latest'
  maintainer 'Patrick Double "pat@patdouble.com"'
  copyFile 'content', '/var/www/localhost/htdocs/'
}

task dockerStaticSiteImage(type: DockerBuildImage) {
  group = 'staging'
  dependsOn dockerStaticSiteDockerfile
  dockerFile = dockerStaticSiteDockerfile.destFile
  inputDir = dockerStaticSiteDockerfile.destFile.parentFile
  tag = "double16/pet-store_site:${'git rev-parse HEAD'.execute().text.trim().take(12) ?: 'latest'}"
}

task dockerStaticSiteCreate(type: DockerCreateContainer) {
  dependsOn dockerStaticSiteImage
  targetImageId { dockerStaticSiteImage.getImageId() }
  portBindings = ['80']
}

task dockerStaticSiteStart(type: DockerStartContainer) {
  dependsOn dockerStaticSiteCreate
  targetContainerId { dockerStaticSiteCreate.getContainerId() }
}

task dockerStaticSiteRemove(type: DockerRemoveContainer) {
  dependsOn dockerStaticSiteCreate
  targetContainerId { dockerStaticSiteCreate.getContainerId() }
  force = true
}

