import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import groovyx.net.http.RESTClient
import org.apache.http.client.methods.HttpPut
import org.apache.http.entity.FileEntity
import org.apache.http.impl.client.DefaultHttpClient

buildscript {
    ext {
        grailsVersion = project.grailsVersion
    }
    repositories {
        mavenLocal()
        if (System.getenv('MAVEN_REPO')) {
          maven { url { System.getenv('MAVEN_REPO') } }
        }
        maven { url "https://repo.grails.org/grails/core" }
    }
    dependencies {
        classpath "org.grails:grails-gradle-plugin:$grailsVersion"
        classpath "com.bertramlabs.plugins:asset-pipeline-gradle:2.14.7"
        classpath "org.grails.plugins:hibernate5:${gormVersion-".RELEASE"}"
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.2'
        classpath 'com.bmuschko:gradle-docker-plugin:3.2.1'
        classpath 'com.netflix.nebula:gradle-lint-plugin:8.3.1'
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.17.0'
    }
}

plugins {
    id 'com.gradle.build-scan' version '1.11'
    id 'com.craigburke.client-dependencies' version '1.4.0'
    id 'com.patdouble.awsecr' version '0.3.3'
}

apply plugin:"eclipse"
apply plugin:"idea"
apply plugin:"war"
apply plugin:"org.grails.grails-web"
apply plugin:"org.grails.grails-gsp"
apply plugin:"asset-pipeline"
apply plugin: "com.bmuschko.docker-remote-api"
apply plugin: 'nebula.lint'

allprojects {
    apply plugin: 'com.github.ben-manes.versions'
}

version "0.1"
group "pet.store"

buildScan {
    licenseAgreementUrl = 'https://gradle.com/terms-of-service'
    licenseAgree = 'yes'
}

ext {
    grailsVersion = project.grailsVersion
    gradleWrapperVersion = project.gradleWrapperVersion
    cacheDir = gradle.getGradleUserHomeDir() as String ?: "${System.getProperty("user.home")}/.cache/gradle"
    new File(cacheDir).mkdirs()

    commit = System.getenv("COMMIT_HASH") ?: "git rev-parse HEAD".execute().text.trim()
    shortCommit = commit.length() > 7 ? commit.substring(0, 7) : commit
    applicationFile = new File(war.archivePath.parentFile, war.archivePath.name.replace('.war', '-app.war'))
}

bootRun {
    jvmArgs('-Dspring.output.ansi.enabled=always')
    addResources = true
}

assets {
    minifyJs = true
    minifyCss = true
}

/** Use the typical docker-machine environment variables to configure docker. */
ext {
    dockerHost = null
    repository = System.getenv('DOCKER_REGISTRY_URL') ?: 'pet-store-app'
}
docker {
    if (System.getenv('DOCKER_TLS_VERIFY') == '1' && System.getenv('DOCKER_CERT_PATH')) {
        url = System.getenv('DOCKER_HOST')?.replaceAll('tcp://', 'https://')
        certPath = new File(System.getenv('DOCKER_CERT_PATH'))
        project.dockerHost = new URL(url).host
    } else if (System.getenv('DOCKER_HOST')) {
        url = System.getenv('DOCKER_HOST')?.replaceAll('tcp://', 'http://')
        project.dockerHost = new URL(url).host
    }

    if (System.getenv('DOCKER_REGISTRY_URL')) {
        registryCredentials {
            url = System.getenv('DOCKER_REGISTRY_URL')
        }
    }
}

populateECRCredentials.onlyIf { System.getenv('DOCKER_REGISTRY_URL')?.contains('.ecr.') }

repositories {
    mavenLocal()
    if (System.getenv('MAVEN_REPO')) {
      maven { url { System.getenv('MAVEN_REPO') } }
    }
    maven { url "https://repo.grails.org/grails/core" }
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.4.10'
    compile "org.grails:grails-plugin-rest:$grailsVersion"
    compile 'org.springframework:spring-tx:4.3.7.RELEASE'
    compile 'io.projectreactor:reactor-core:2.0.8.RELEASE'
    compile 'org.apache.tomcat.embed:tomcat-embed-core:8.5.13'
    compile "org.grails:grails-web-sitemesh:$grailsVersion"
    compile "org.grails:grails-bootstrap:$grailsVersion"
    compile 'org.springframework:spring-beans:4.3.7.RELEASE'
    compile 'org.springframework.boot:spring-boot:1.4.6.RELEASE'
    compile 'org.springframework:spring-context:4.3.7.RELEASE'
    compile "org.grails:grails-web-url-mappings:$grailsVersion"
    compile "org.grails:grails-plugin-mimetypes:$grailsVersion"
    compile 'org.springframework:spring-webmvc:4.3.7.RELEASE'
    compile "org.grails:grails-web-databinding:$grailsVersion"
    compile "org.grails:grails-databinding:$grailsVersion"
    compile 'org.grails:grails-datastore-core:6.0.10.RELEASE'
    compile "org.grails:grails-web-common:$grailsVersion"
    compile "org.grails:grails-plugin-async:$grailsVersion"
    compile "org.grails:grails-web-taglib:$grailsVersion"
    compile 'org.grails:grails-datastore-gorm:6.0.10.RELEASE'
    compile "org.grails:grails-taglib:$grailsVersion"
    compile 'io.projectreactor:reactor-bus:2.0.8.RELEASE'
    compile 'org.codehaus.groovy:groovy:2.4.10'
    compile "org.grails:grails-plugin-events:$grailsVersion"
    compile "org.grails:grails-web-mvc:$grailsVersion"
    compile 'org.slf4j:slf4j-api:1.7.25'
    compile "org.grails:grails-plugin-converters:$grailsVersion"
    compile "org.grails:grails-plugin-controllers:$grailsVersion"
    compile 'org.springframework:spring-web:4.3.7.RELEASE'
    compile "org.grails:grails-plugin-domain-class:$grailsVersion"
    testCompile 'org.grails:grails-datastore-simple:6.0.10.RELEASE'
    testCompile 'org.springframework:spring-test:4.3.7.RELEASE'
    testCompile 'junit:junit:4.12'
    testCompile "org.grails:grails-test:$grailsVersion"
    compile "org.springframework.boot:spring-boot-autoconfigure"
    compile "org.springframework.boot:spring-boot-actuator"
    compile "org.grails:grails-core"
    compile "org.grails:grails-dependencies"
    compile "org.grails:grails-web-boot"
    runtime 'org.hibernate:hibernate-ehcache:5.1.3.Final'
    console "org.grails:grails-console"
    profile "org.grails.profiles:web"
    runtime "com.bertramlabs.plugins:asset-pipeline-grails:2.14.7"
    runtime "org.grails.plugins:scaffolding"
    runtime "org.grails.plugins:cache"
    runtime "com.h2database:h2"
    testCompile "org.grails:grails-plugin-testing"

    // Note: It is recommended to update to a more robust driver (Chrome, Firefox etc.)
    testRuntime "org.seleniumhq.selenium:selenium-htmlunit-driver:2.52.0"
    testRuntime "net.sourceforge.htmlunit:htmlunit:2.29"

    console "org.grails:grails-console"
}

clientDependencies {
    yarn {
        'jquery'('~2.1.0')
        "angular"("~1.3.15")
        "angular-route"("~1.3.15")
        "angular-loader"("~1.3.15")
        "angular-animate"("~1.3.15")
        "angular-cookies"("~1.3.15")
        "angular-resource"("~1.3.15")
        "angular-sanitize"("~1.3.15")
        "angular-touch"("~1.3.15")
        "angular-mocks"("~1.3.15")
        "animate.css"("3.x")
    }
}

allprojects {
    dependencyUpdates.resolutionStrategy = {
        componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                if (['.M', '.RC', 'beta', 'alpha', '-rc'].find {
                    selection.candidate.version.toLowerCase().contains(it.toLowerCase())
                }) {
                    selection.reject('unreleased')
                }
            }
        }
    }

    gradleLint.rules = ['all-dependency','dependency-parenthesis','dependency-tuple']
    autoLintGradle.onlyIf { false }
}

task wrapper(type: Wrapper) {
    gradleVersion = gradleWrapperVersion
}

// Using a different output file allows incremental build, 'classifier' property doesn't work
bootRepackage {
    inputs.file(war.archivePath)
    outputs.file(applicationFile)
    setOutputFile(applicationFile)
}

/**
 * Uploading a source tarball with the compiled jar and an empty maven build to make the Java buildpack happy
 */
task emptyPom {
    outputs.file('build/pom.xml')
    doLast {
        new File('build/pom.xml').text = """
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>pet.store</groupId>
  <artifactId>placeholder</artifactId>
  <packaging>jar</packaging>
  <version>1.0</version>
  <name>Pet Store</name>
  <build>
    <finalName>placeholder</finalName>
  </build>
</project>
"""
    }
}

task herokuSources(type: Tar, dependsOn: [emptyPom, bootRepackage]) {
    description = "Package binary application into Heroku sources for faster deployment"
    group = "distribution"
    appendix = "heroku"
    compression = Compression.GZIP
    from 'Procfile'
    from 'system.properties'
    from 'build/pom.xml'
    into('src/main/dist') {
       from applicationFile
    }
}

// Documentation at https://devcenter.heroku.com/articles/build-and-release-using-the-api
task deployToHeroku(dependsOn: herokuSources) {
    description = 'Deploy the application to Heroku via the Platform API REST services'
    group = "distribution"
    doLast {
        RESTClient heroku = new RESTClient("https://api.heroku.com/apps/${System.getenv("HEROKU_APP_NAME")}/")
        heroku.headers['Authorization'] = "Bearer ${System.getenv('HEROKU_AUTH_TOKEN')}"
        heroku.headers['Accept'] = 'application/vnd.heroku+json; version=3'

        // upload sources
        def sources = heroku.post(path: 'sources')
        def put_url = sources.data.source_blob.put_url
        def get_url = sources.data.source_blob.get_url

        // upload sources, Heroku/AWS is very picky about the headers sent, so we need to use this way. For example, Content-Type must not be present
        logger.info("Uploading ${herokuSources.archivePath} to ${put_url}")
        def res = new DefaultHttpClient().execute(new HttpPut(URI: new URI(put_url), entity: new FileEntity(herokuSources.archivePath)))
        if (res.statusLine.statusCode > 399) {
            throw new IOException(res.statusLine.reasonPhrase)
        }

        // start the build
        logger.info("Building ${get_url}")
        heroku.post(path: 'builds', requestContentType: 'application/json',
            body: ['source_blob': ['url':get_url, 'version': "git rev-parse HEAD".execute().text.trim() ]]
        )
    }
    onlyIf { System.getenv('HEROKU_AUTH_TOKEN') && System.getenv('HEROKU_APP_NAME') }
}

processResources.dependsOn clientInstall
assetCompile.dependsOn clientInstall

build.dependsOn ':staticsite:generate'

/**
 * Container based tasks follow. These tasks allow all build operations to be done in containers,
 * thus reducing the dependencies required on the build host to be Java and Docker.
 */

/** The `dockerOutput` directory holds all build outputs from the containers. */
ext {
  dockerOutput = "${project.buildDir}/docker/output"
}

task dockerResources(type: Sync) {
    group = "staging"
    into "${project.buildDir}/docker-resources"
    from 'src/main/docker'
}

task webappContext(type: Sync) {
    group = "staging"
    into "${project.buildDir}/docker/webapp"
    from project.buildDir
    dependsOn bootRepackage, dockerResources

    include applicationFile.absolutePath.replaceFirst("${project.buildDir}/", '')
    include 'docker-resources/**/*'
}

task webappDockerfile(type: Dockerfile) {
    group = "staging"
    dependsOn bootRepackage, webappContext
    destFile = project.file("${project.buildDir}/docker/webapp/Dockerfile")
    from 'openjdk:8u151-jre-alpine'

    environmentVariable "TERM", "dumb"

    runCommand 'apk add --no-cache curl && rm -rf /tmp/*'

    exposePort 8080, 8000
    instruction 'HEALTHCHECK --interval=1m --timeout=20s --start-period=2m CMD curl -f http://localhost:8080/health || exit 1'

    workingDir '/app'
    copyFile 'docker-resources/start-grails.sh', '/app/start-grails.sh'
    runCommand 'chmod +x /app/start-grails.sh'
    defaultCommand '/app/start-grails.sh'

    label([
            'maintainer'                 : 'Patrick Double "pat@patdouble.com"',
            //'org.label-schema.build-date': Instant.now().toString(),
            'org.label-schema.vendor'    : "https://github.com/double16",
            'org.label-schema.license'   : "Apache-2.0",
            'org.label-schema.name'      : "Pet Store Application",
            'org.label-schema.url'       : "https://github.com/double16/pet-store",
            'org.label-schema.vcs-ref'   : shortCommit,
            'org.label-schema.vcs-type'  : 'git',
            'org.label-schema.vcs-url'   : "https://github.com/double16/pet-store.git"
    ])

    copyFile applicationFile.absolutePath.replaceFirst("${project.buildDir}/", ''), '/app/'
}

task webappImage(type: DockerBuildImage) {
    dependsOn webappDockerfile, webappContext
    inputs.file applicationFile
    dockerFile = webappDockerfile.destFile
    inputDir = dockerFile.parentFile
    tag = "${repository}:${shortCommit ?: 'latest'}"
}

task webappImagePublish(type: DockerPushImage) {
    group = "staging"
    dependsOn webappImage
    imageName = webappImage.tag
    tag = shortCommit ?: 'latest'
}

/**
 * Static site container.
 */
task staticContext(type: Sync) {
  group = "staging"
  dependsOn ':staticsite:generate'
  into "${project.buildDir}/docker/staticsite/content"
  from project(':staticsite').file('target')
}

task staticDockerfile(type: Dockerfile) {
  group = 'staging'
  dependsOn staticContext
  destFile = file("${project.buildDir}/docker/staticsite/Dockerfile")
  from 'sebp/lighttpd:latest'
  maintainer 'Patrick Double "pat@patdouble.com"'
  copyFile 'content', '/var/www/localhost/htdocs/'
}

task staticImage(type: DockerBuildImage) {
  group = 'staging'
  dependsOn staticDockerfile
  dockerFile = staticDockerfile.destFile
  inputDir = staticDockerfile.destFile.parentFile
  tag = "${repository}-site:${shortCommit ?: 'latest'}"
}

task staticSiteCreate(type: DockerCreateContainer) {
  dependsOn staticImage
  targetImageId { staticImage.getImageId() }
  portBindings = ['80']
}

task staticSiteStart(type: DockerStartContainer) {
  dependsOn staticSiteCreate
  targetContainerId { staticSiteCreate.getContainerId() }
}

task staticSiteRemove(type: DockerRemoveContainer) {
  dependsOn staticSiteCreate
  targetContainerId { staticSiteCreate.getContainerId() }
  force = true
}
